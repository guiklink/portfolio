---
layout: project
title: 2D Quadrotor Optimization
repository:
date: 
image: https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/logo.png?raw=true
---

[Mathematica Code](/home/klink/MS_Robotics/ME454_Optimal_Control/Final Project/GK_Quad_Animated-1.nb) *this file has .nb extendion and can probably only be read properlly with Wolfran Mathematica*

[Write Up](https://github.com/guiklink/portfolio/blob/gh-pages/public/Documents/2D_Quad/write_up.pdf)

<article></article><br/>

# Introduction
As my final project for the Numerical Methods in Optimal Control class I applied a Gradient Descent and some of its different techniques (e.g. Armijo Theorem, Ricatti Theorem, trajectory projections) on quadrotors, one of my main areas of interest. The goal is to optimize the force input needed to be generated by its rotors in order to be compliant to a given trajectory in the best way possible according to its dynamics. 
For this project I used Wolfram Mathematica, the recommended software for the class and due to its facility in performing symbolic calculation, plots and animations. However, Mathematica does not achieve the same performance as languages such as C++ and since complex calculations will need to be done, one of the drawbacks of this project is the time it takes processing before generating an animation. In order to optimize the process by simplifying the math, I reduced the number of differential equations in the dynamics of the quadrotor, so let's assume instead we are using a "dualrotor" the quadrotor of the 2D world, as shown in the scheme bellow:

![2D_quadrotor](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/2dQuad_1.png?raw=true)

In the representation above the X-axis points to the righ, the Y-axis points to the interior of the screen and the Z-axis points down. F1 and F2 are forces caused by the trust generated by the rotors 1 and 2, which can move the "dualrotor" by translations in XZ-plane and a rotation ϴ around the Y-axis ([Pitch](https://en.wikipedia.org/wiki/Flight_dynamics#/media/File:Yaw_Axis_Corrected.svg)).

## Code and Animation 
The [algorithm](/home/klink/MS_Robotics/ME454_Optimal_Control/Final Project/GK_Quad_Animated-1.nb) will provide an animation of a bar like 2D Quad rotor as well as the plots for {x, z, ϴ}.

<iframe src="https://player.vimeo.com/video/138922599" width="500" height="529" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe> <p><a href="https://vimeo.com/138922599">2DQuad_Loop</a> from <a href="https://vimeo.com/user43396191">Guilherme Klink</a> on <a href="https://vimeo.com">Vimeo</a>.</p>

![X_Plot](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/x_plot.png?raw=true)   
![Z_Plot](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/z_plot.png?raw=true)   
![ϴ_Plot](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/delta_plot.png?raw=true)   

## Getting a 2D-Quadrotor
A [quadrotor](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/flying_robots/crazy_flie.JPG?raw=true) is a flying machine composed by four rotors equidistant from each other, with center of mass in its middle. Its flight is controlled by the difference of upward forces generated by the thrust of each rotor as schematized in the figure bellow.

![3D_quadrotor](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/2dQuad_2.png?raw=true)

### Disconsider 2 rotors
In a 2D representation we are going to assume that rotors 3 and 4 do not produce thrust (therefore F3=0 N and F4=0 N) and to eliminate [Yaw (φ)](https://en.wikipedia.org/wiki/Flight_dynamics#/media/File:Yaw_Axis_Corrected.svg) we have to assume the propellers do not create any [Hub]() horizontal force on its blades.

### Move only in one plane
Since we are not considering rotors 3 and 4 we can eliminate [Roll (ψ)](https://en.wikipedia.org/wiki/Flight_dynamics#/media/File:Yaw_Axis_Corrected.svg). The quad rotor cannot move without tilting for the direction it wants to go, therefore it needs to roll to be able to move on the Y-axis, thus since we eliminated roll, from now on it will only be able to move on the 2D plane XZ.

### Remaining degrees of freedom
We end up with the following possible movements that will be used to compose the 2D Quad rotor state with 3 DOF:

* **X**: when the quad tilts with ϴ it can moves in the X-axis
* **Z**: the movement in this axis is defined by the sum of the z-components of F1 and F3.
* **ϴ**: it can tilt by the resultant moment of F1 and F2.  

## 2D-Quadrotor dynamics
The derivation of the dynamics of the 2D-Quadrotor can be seen at [Section 1 of the write up](https://github.com/guiklink/portfolio/blob/gh-pages/public/Documents/2D_Quad/write_up.pdf).  

## The Projection
For our gradient descent algorithm it is important to have a good [Projection](https://en.wikipedia.org/wiki/Gradient_descent) function (denoted by P). The projection function has the purpose of converting any simplified non-feasible state to a feasible state, in other words, it converts to a state that is compliant to the quadrotor dynamics. The way this function can be obtained is showed [in Section 2](https://github.com/guiklink/portfolio/blob/gh-pages/public/Documents/2D_Quad/write_up.pdf).  

## The Cost Function
A basic quadratic cost equation was used since this types of functions generate a parabola. The reason a parabola cost function is interesting for a gradient descent algorithm is that for this particular shapes the local and global minimum coincide (as shown in the figure below).

![Parabola](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/quadratic_func.png?raw=true)

Therefore is guaranteed that the algorithm will always be able to find the lowest cost without getting stuck in a local minimum. The specific quadratic function used as the way its constants were tuned can be found in [Section 3](https://github.com/guiklink/portfolio/blob/gh-pages/public/Documents/2D_Quad/write_up.pdf). 

## Armijo Line Search
The [Armijo line search](https://en.wikipedia.org/wiki/Backtracking_line_search) innequation is used to guarantee that on each step the gradient descent will descent and eventually achieve an optimal solution.

# Conclusion
Unfortunattelly, the Mathematica running performance makes this alghorithm unfeasable for a real life quadrotor aplication (it would run for hours and problem overflow the computer's memory), however it was important for my understanding of how implement a Gradient Descent Optimization for a complex problem and to polish my skills with quarotor dynamics. I hope in the future to implement the same solution using a faster programming language.  