---
layout: project
title: 2D Quadrotor Optimization
date: February 10, 2015
image: https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/logo.png?raw=true
---

[Code and Animation](https://onedrive.live.com/redir?resid=8CCE026E90681641!1418&authkey=!AFvab3AvaxnHaMg&ithint=file%2cnb)

# Introduction
As my final project for the Numerical Methods in Optimal Control class I applied a Gradient Descent and some of its different techniques (e.g. Armijo Theorem, Ricatti Theorem, trajectory projections) on quadrotors, one of my main areas of interest. The goal is to optimize the force input needed to be generated by its rotors in order to be compliant to a given trajectory in the best way possible according to its dynamics. 
For this project I used Wolfram Mathematica, the recommended software for the class and due to its facility in performing symbolic calculation, plots and animations. However, Mathematica does not achieve the same performance as languages such as C++ and complex calculations will need to be done, therefore one of the drawbacks of this project is the time it takes processing before generating an animation. In order to optimize the process by simplifying the math, I reduced the number of differential equations in the dynamics of the quadrotor. Let's assume instead we are using a "dualrotor" the quadrotor of the 2D world, as shown in the scheme bellow:

![2D_quadrotor](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/2dQuad_1.png?raw=true)

In the representation above the X-axis point to the righ, the Y-axis points to the interior of the screen and the Z-axis points down. F1 and F2 are forces caused by the trust generated by the rotors 1 and 2, which can move the "dualrotor" by translations in X-axis and Z-axis and a rotation ϴ around the Y-axis ([Pitch](https://en.wikipedia.org/wiki/Flight_dynamics#/media/File:Yaw_Axis_Corrected.svg)).

## Code and Animation 
The [algorithm](https://onedrive.live.com/redir?resid=8CCE026E90681641!1418&authkey=!AFvab3AvaxnHaMg&ithint=file%2cnb) will take around five minutes to run and will provide an animation of a bar like 2D Quad rotor as well as the plots for {x, z, ϴ}.  In order to try to make the execution faster I have increased the maximum error allowed to Є=10, however the cost converges and given enough time (if you are patient enough) it will provide even better results than 10, probably converging to something very close to 0 eventually.  

## Getting a 2D-Quadrotor
A quadrotor is a flying machine composed by four rotors equidistant from each other, with center of mass in its middle. Its flight is controlled by the difference of upward forces generated by the thrust of each rotor as schematized in the figure bellow.

![3D_quadrotor](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/2dQuad_2.png?raw=true)

### Disconsider 2 rotors
In a 2D representation we are going to assume that rotors 3 and 4 do not produce thrust (therefore F3=0 N and F4=0 N) and to eliminate yaw (φ) we have to assume the propellers do not create any Hub horizontal force on its blades.

### Move only in one plane
Since we are not considering rotors 3 and 4 we can eliminate roll (ψ). The quad rotor cannot move without tilting for the direction it wants to go, therefore it needs to roll to be able to move on the Y-axis, thus since we eliminated roll from now on it will only be able to move on the 2D plane XZ.

### Remaining degrees of freedom
We end up with the following possible movements that will be used to compose the 2D Quad rotor state with 3 DOF:

* **X**: when the quad tilts with ϴ it can moves in the X-axis
* **Z**: the movement in this axis is defined by the sum of the z-components of F1 and F3.
* **ϴ**: it can tilt by the resultant moment of F1 and F2.  

## 2D-Quadrotor dynamics
The derivation of the dynamics of the 2D-Quadrotor can be seen at [item 1]().  

## The Projection
For our gradient descent algorithm it is important to have a good Projection function (denoted by P). The projection function has the purpose of converting any non-feasible state to a feasible state, in other words, a state that is compliant to the quadrotor dynamics. The way this function can be derived is showed [in item 2]().  

## The Cost Function
A basic quadratic cost equation was used since this types of functions generate a parabola. The reason a parabola cost function is interesting for a gradient descent algorithm is that for this particular shapes the local and global minimum coincide (as shown in the figure below).

![Parabola](https://github.com/guiklink/portfolio/blob/gh-pages/public/images/2D_quad_opt/quadratic_func.png?raw=true)

Therefore is guaranteed that the algorithm will always be able to find the lowest cost without getting stuck in a local minimum. The specific quadratic function used as the way its constants were tuned can be found in [item 3](). 

## Armijo Line Search
The [Armijo line search](https://en.wikipedia.org/wiki/Backtracking_line_search) innequation is used to guarantee that on each step the gradient descent will descent and eventually achieve an optimal solution.
